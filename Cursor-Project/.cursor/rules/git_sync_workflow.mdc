---
description: Standalone Git sync workflow rule with readonly token. Apply when user requests to fetch projects, update branches (dev, dev2, dev-fix, test), or checkout branches using trigger keywords `!sync`, `!update`, or `!checkout <branch>`. Handles stash/unstash of local changes automatically. Uses readonly Personal Access Token for authentication. Supports all Phoenix projects in Phoenix/ directory. IMPORTANT: This rule performs LOCAL operations only (fetch, checkout, local merge) - NO push, commit, or remote modifications. Fully compatible with safety rules.
alwaysApply: false
---

# Git Sync Workflow Rule (Standalone with Readonly Token)

## ⚠️ CRITICAL: Configure Your Token

**This file is completely standalone and includes a readonly Git Personal Access Token for fetching projects.**

**Before using this rule:**
1. **Add your readonly Git Personal Access Token** in the "Git Readonly Token" section below
2. **Verify repository paths** - The rule uses relative paths that work from workspace root
3. **Verify repository remote URLs** match your setup

---

## When to Apply

This rule applies when:
- **Primary triggers:** 
  - `!sync` - Fetch all projects and update current branches
  - `!update <branch>` - Update specified branches (dev, dev2, dev-fix, test)
  - `!checkout <branch>` - Checkout specified branch (dev, dev2, dev-fix, test)
- User requests to fetch projects from remote
- User wants to update specific branches
- User wants to checkout a branch
- User wants to download or update projects from GitLab

---

## Process Overview

The sync workflow supports three main operations:

1. **Initial Fetch** - Fetch all available projects from remote using readonly token
2. **Update Branches** - Update specified branches (dev, dev2, dev-fix, test) from remote
3. **Checkout Branches** - Checkout specified branches (dev, dev2, dev-fix, test)

---

## Git Readonly Token Configuration

### ✅ TOKEN CONFIGURED

**Note:** GitLab readonly token is configured and ready to use.

**Your Git Configuration:**
- **Git Host:** `git.domain.internal` (GitLab)
- **Repositories:** All Phoenix projects in `Phoenix/` directory
  - `phoenix-core-lib` (https://git.domain.internal/phoenix/phoenix-core-lib.git)
  - `phoenix-core` (https://git.domain.internal/phoenix/phoenix-core.git)
  - `phoenix-billing-run` (https://git.domain.internal/phoenix/phoenix-billing-run.git)
  - `phoenix-api-gateway` (https://git.domain.internal/phoenix/phoenix-api-gateway.git)
  - `phoenix-payment-api` (https://git.domain.internal/phoenix/phoenix-payment-api.git)
  - `phoenix-migration` (https://git.domain.internal/phoenix/phoenix-migration.git)
  - `phoenix-ui` (https://git.domain.internal/phoenix/phoenix-ui.git)
  - And other Phoenix projects as they exist

**GitLab Readonly Personal Access Token (configured):**

```bash
# GitLab Readonly Personal Access Token
# This token is used for all git fetch operations
# Token has read-only access to repositories
GIT_READONLY_TOKEN="glpat-s3G3rmuJUPbsJBns039NRG86MQp1OjNzCA.01.0y0s67eqg"
```

**Current Token Configuration:**
- **Token Value:** `glpat-s3G3rmuJUPbsJBns039NRG86MQp1OjNzCA.01.0y0s67eqg` (configured)
- **Token Type:** GitLab Personal Access Token (read-only)
- **Permissions Required:** read_repository, read_api
- **Repositories:** All Phoenix projects
- **Git Host:** git.domain.internal

**How to get a GitLab readonly token:**
1. Log into GitLab at `https://git.domain.internal`
2. Go to User Settings → Access Tokens (or Preferences → Access Tokens)
3. Create a new token with:
   - **Name:** `readonly-git-sync` (or any descriptive name)
   - **Scopes:** Select `read_api` and `read_repository` (read-only permissions)
   - **Expiration:** Set as needed (or leave blank for no expiration)
4. Click "Create personal access token"
5. **Copy the token immediately** (it starts with `glpat-` and won't be shown again)
6. Token is already configured in this file

**Token Requirements:**
- **Scope:** Read-only access (read_api, read_repository)
- **Permissions:** Read access to all Phoenix repositories
- **Security:** This is a readonly token - it cannot modify repositories
- **Format:** GitLab tokens start with `glpat-` followed by alphanumeric characters

**Example Token Format:**
- GitLab: `glpat-xxxxxxxxxxxxxxxxxxxx` (typically 20+ characters)

**⚠️ IMPORTANT:** 
- The readonly token is configured and ready to use
- This token has read-only access and cannot modify repositories
- Keep this token secure and do not share it publicly

---

## Workspace Configuration

### Workspace Root Detection

**The rule automatically detects the workspace root using one of these methods:**
1. **Environment Variable:** `$WORKSPACE_ROOT` (if set)
2. **Current Directory:** Uses `pwd` to detect workspace root
3. **Relative Paths:** Works from any directory within the workspace

**Repository Paths (Relative to Workspace Root):**
- All Phoenix projects are in `Phoenix/` subdirectory
- **phoenix-core-lib:** `Phoenix/phoenix-core-lib/` (relative path)
- **phoenix-core:** `Phoenix/phoenix-core/` (relative path)
- **phoenix-billing-run:** `Phoenix/phoenix-billing-run/` (relative path)
- And other projects as they exist

**How It Works:**
- The rule navigates to workspace root first
- Then uses relative paths to access repositories in `Phoenix/` directory
- Works on Windows (Git Bash/PowerShell), Linux, and macOS
- No hardcoded absolute paths required
- Automatically discovers all Git repositories in `Phoenix/` directory

### Repository Remote URLs

**Current Configuration:**
- **Remote Name:** `origin`
- **Git Host:** Detected from `git remote get-url origin`
- **Repositories:** All Git repositories found in `Phoenix/` directory

**Note:** The token will be used to authenticate with these remotes. The rule automatically detects the Git host and repository paths from the git remote configuration.

---

## Step-by-Step Process

### Step 1: Initial Fetch (All Projects)

**Trigger:** `!sync` (without branch specification)

**Action:** Fetch all available projects from remote repositories using readonly token

**Process:**
1. **Detect Workspace Root**
   - Use `$WORKSPACE_ROOT` if set, otherwise use current directory or detect from git repos
   - Navigate to workspace root

2. **Discover Phoenix Projects**
   - Scan `Phoenix/` directory for all Git repositories
   - For each directory in `Phoenix/` that contains a `.git` folder, add it to the list

3. **Check for Uncommitted Changes**
   - Check all discovered Phoenix repositories
   - Use `git status --porcelain` to detect uncommitted changes
   - **If uncommitted changes found:** Automatically stash them before fetch
   - Stash message: "Stashed before fetch - preserving local changes"

4. **Configure Git Authentication with Token**
   - Set up git to use the readonly token for authentication
   - Configure credential helper or embed token in remote URL

5. **Fetch All Projects**
   - For each repository in `Phoenix/`:
     - Navigate to repository directory (relative path: `Phoenix/<repo-name>/`)
     - `git fetch origin --all` (fetch all branches and tags)
     - `git fetch origin --prune` (remove deleted remote branches)

6. **Unstash Changes**
   - **After successful fetch:** Automatically unstash: `git stash pop`
   - Report: "All projects fetched successfully."

**Implementation with Token (Cross-Platform Compatible):**
```bash
# Set readonly token
GIT_READONLY_TOKEN="glpat-s3G3rmuJUPbsJBns039NRG86MQp1OjNzCA.01.0y0s67eqg"

# Detect workspace root
if [ -n "$WORKSPACE_ROOT" ]; then
    WORKSPACE_DIR="$WORKSPACE_ROOT"
else
    # Try to detect from current directory
    if [ -d "Phoenix" ]; then
        WORKSPACE_DIR="$(pwd)"
    elif [ -d "../Phoenix" ]; then
        WORKSPACE_DIR="$(cd .. && pwd)"
    else
        # Try to find Phoenix directory
        WORKSPACE_DIR="$(pwd)"
        while [ "$WORKSPACE_DIR" != "/" ] && [ ! -d "$WORKSPACE_DIR/Phoenix" ]; do
            WORKSPACE_DIR="$(dirname "$WORKSPACE_DIR")"
        done
    fi
fi

cd "$WORKSPACE_DIR" || exit 1

# Configure git credential helper with token
if [ -n "$GIT_READONLY_TOKEN" ]; then
    git config --global credential.helper store
    # Detect git host from first repository found
    if [ -d "Phoenix/phoenix-core-lib" ]; then
        cd Phoenix/phoenix-core-lib
        GIT_HOST=$(git remote get-url origin 2>/dev/null | sed -E 's|https?://([^/]+).*|\1|' | sed 's|.*@||')
        cd ../..
    fi
    # Store credentials (works for GitLab, GitHub, etc.)
    if [ -n "$GIT_HOST" ]; then
        CREDENTIALS_FILE="$HOME/.git-credentials"
        if [ "$OS" = "Windows_NT" ] || [ -n "$WINDIR" ]; then
            # Windows: use USERPROFILE
            CREDENTIALS_FILE="${USERPROFILE:-$HOME}/.git-credentials"
        fi
        echo "https://oauth2:${GIT_READONLY_TOKEN}@${GIT_HOST}" > "$CREDENTIALS_FILE"
    fi
fi

# Discover and process all Phoenix projects
if [ -d "Phoenix" ]; then
    cd Phoenix
    for repo_dir in */; do
        repo_dir="${repo_dir%/}"
        if [ -d "$repo_dir/.git" ]; then
            echo "Processing: Phoenix/$repo_dir"
            cd "$repo_dir"
            
            # Stash uncommitted changes
            if [ -n "$(git status --porcelain 2>/dev/null)" ]; then
                git stash push -m "Stashed before fetch - preserving local changes"
                STASHED=true
            else
                STASHED=false
            fi
            
            # Fetch from remote
            git fetch origin --all
            git fetch origin --prune
            
            # Unstash if needed
            if [ "$STASHED" = "true" ]; then
                git stash pop 2>/dev/null || true
            fi
            
            cd ..
        fi
    done
    cd ..
fi
```

---

### Step 2: Update Specified Branch

**Trigger:** `!update <branch>` or `!sync <branch>` (e.g., `!update dev`, `!sync dev2`)

**Supported Branches:** `dev`, `dev2`, `dev-fix`, `test`, `main`, `master`

**Action:** Update specified branch from remote in all Phoenix repositories using readonly token

**Process:**
1. **Detect Workspace Root** (same as Step 1)
2. **Discover Phoenix Projects** (same as Step 1)
3. **Check for Uncommitted Changes** (same as Step 1)
4. **Configure Git Authentication with Token** (same as Step 1)
5. **Check Current Branch**
   - Verify current branch in all repositories
   - Log current branch for reference

6. **Fetch Latest Changes**
   - Fetch from remote: `git fetch origin`
   - Check if local branch exists: `git show-ref --verify --quiet refs/heads/<branch>`
   - If branch doesn't exist locally, create tracking branch: `git checkout -b <branch> origin/<branch>`

7. **Check Branch Status**
   - Check if local branch is behind remote: `git rev-list --count HEAD..origin/<branch>`
   - Check if local branch is ahead: `git rev-list --count origin/<branch>..HEAD`
   - Check if local branch has diverged: both ahead and behind counts are non-zero

8. **Update Branch**
   - **If branch has diverged:** ABORT and ask user how to proceed (merge/rebase/reset/abort)
   - **If branch is behind:** Merge remote changes: `git merge origin/<branch>`
   - **If branch is up to date:** Report: "Branch <branch> is already up to date."

9. **Unstash Changes**
   - **After successful update:** Automatically unstash: `git stash pop`
   - If merge conflicts occurred, keep stashed and inform user

**Implementation with Token (Cross-Platform Compatible):**
```bash
BRANCH="dev"  # or dev2, dev-fix, test, main, master
GIT_READONLY_TOKEN="glpat-s3G3rmuJUPbsJBns039NRG86MQp1OjNzCA.01.0y0s67eqg"

# Detect workspace root and configure token (same as Step 1)
if [ -n "$WORKSPACE_ROOT" ]; then
    WORKSPACE_DIR="$WORKSPACE_ROOT"
else
    if [ -d "Phoenix" ]; then
        WORKSPACE_DIR="$(pwd)"
    elif [ -d "../Phoenix" ]; then
        WORKSPACE_DIR="$(cd .. && pwd)"
    else
        WORKSPACE_DIR="$(pwd)"
        while [ "$WORKSPACE_DIR" != "/" ] && [ ! -d "$WORKSPACE_DIR/Phoenix" ]; do
            WORKSPACE_DIR="$(dirname "$WORKSPACE_DIR")"
        done
    fi
fi

cd "$WORKSPACE_DIR" || exit 1

# Configure git credential helper with token (same as Step 1)
if [ -n "$GIT_READONLY_TOKEN" ]; then
    git config --global credential.helper store
    if [ -d "Phoenix/phoenix-core-lib" ]; then
        cd Phoenix/phoenix-core-lib
        GIT_HOST=$(git remote get-url origin 2>/dev/null | sed -E 's|https?://([^/]+).*|\1|' | sed 's|.*@||')
        cd ../..
    fi
    if [ -n "$GIT_HOST" ]; then
        CREDENTIALS_FILE="$HOME/.git-credentials"
        if [ "$OS" = "Windows_NT" ] || [ -n "$WINDIR" ]; then
            CREDENTIALS_FILE="${USERPROFILE:-$HOME}/.git-credentials"
        fi
        echo "https://oauth2:${GIT_READONLY_TOKEN}@${GIT_HOST}" > "$CREDENTIALS_FILE"
    fi
fi

# Process all Phoenix projects
if [ -d "Phoenix" ]; then
    cd Phoenix
    for repo_dir in */; do
        repo_dir="${repo_dir%/}"
        if [ -d "$repo_dir/.git" ]; then
            echo "Updating branch $BRANCH in: Phoenix/$repo_dir"
            cd "$repo_dir"
            
            # Stash uncommitted changes
            if [ -n "$(git status --porcelain 2>/dev/null)" ]; then
                git stash push -m "Stashed before branch update - preserving local changes"
                STASHED=true
            else
                STASHED=false
            fi
            
            # Checkout branch if needed
            CURRENT_BRANCH=$(git branch --show-current 2>/dev/null)
            if [ "$CURRENT_BRANCH" != "$BRANCH" ]; then
                if git show-ref --verify --quiet refs/heads/$BRANCH 2>/dev/null; then
                    git checkout $BRANCH
                else
                    git fetch origin
                    if git ls-remote --heads origin $BRANCH 2>/dev/null | grep -q $BRANCH; then
                        git checkout -b $BRANCH origin/$BRANCH
                    else
                        echo "Branch $BRANCH does not exist on remote for $repo_dir"
                        [ "$STASHED" = "true" ] && git stash pop 2>/dev/null || true
                        cd ..
                        continue
                    fi
                fi
            fi
            
            # Fetch and check status
            git fetch origin
            BEHIND=$(git rev-list --count HEAD..origin/$BRANCH 2>/dev/null || echo "0")
            AHEAD=$(git rev-list --count origin/$BRANCH..HEAD 2>/dev/null || echo "0")
            
            if [ "$AHEAD" != "0" ] && [ "$BEHIND" != "0" ]; then
                echo "Branch $BRANCH has diverged in $repo_dir!"
                [ "$STASHED" = "true" ] && git stash pop 2>/dev/null || true
                cd ..
                continue
            fi
            
            if [ "$BEHIND" != "0" ]; then
                git merge origin/$BRANCH
            else
                echo "Branch $BRANCH is up to date in $repo_dir"
            fi
            
            # Unstash if needed
            if [ "$STASHED" = "true" ]; then
                git stash pop 2>/dev/null || true
            fi
            
            cd ..
        fi
    done
    cd ..
fi
```

---

### Step 3: Checkout Branch

**Trigger:** `!checkout <branch>` (e.g., `!checkout dev`, `!checkout dev2`)

**Supported Branches:** `dev`, `dev2`, `dev-fix`, `test`, `main`, `master`

**Action:** Checkout specified branch in all Phoenix repositories using readonly token

**Process:**
1. **Detect Workspace Root** (same as Step 1)
2. **Discover Phoenix Projects** (same as Step 1)
3. **Check for Uncommitted Changes** (same as Step 1)
4. **Configure Git Authentication with Token** (same as Step 1)
5. **Fetch Latest Changes**
   - Fetch from remote: `git fetch origin`

6. **Checkout Branch**
   - **If branch exists locally:** `git checkout <branch>`
   - **If branch doesn't exist locally:** Create tracking branch: `git checkout -b <branch> origin/<branch>`
   - **If branch doesn't exist on remote:** Report error and skip that repository

7. **Unstash Changes**
   - **After successful checkout:** Automatically unstash: `git stash pop`

**Implementation with Token (Cross-Platform Compatible):**
```bash
BRANCH="dev"  # or dev2, dev-fix, test, main, master
GIT_READONLY_TOKEN="glpat-s3G3rmuJUPbsJBns039NRG86MQp1OjNzCA.01.0y0s67eqg"

# Detect workspace root and configure token (same as Step 1)
if [ -n "$WORKSPACE_ROOT" ]; then
    WORKSPACE_DIR="$WORKSPACE_ROOT"
else
    if [ -d "Phoenix" ]; then
        WORKSPACE_DIR="$(pwd)"
    elif [ -d "../Phoenix" ]; then
        WORKSPACE_DIR="$(cd .. && pwd)"
    else
        WORKSPACE_DIR="$(pwd)"
        while [ "$WORKSPACE_DIR" != "/" ] && [ ! -d "$WORKSPACE_DIR/Phoenix" ]; do
            WORKSPACE_DIR="$(dirname "$WORKSPACE_DIR")"
        done
    fi
fi

cd "$WORKSPACE_DIR" || exit 1

# Configure git credential helper with token (same as Step 1)
if [ -n "$GIT_READONLY_TOKEN" ]; then
    git config --global credential.helper store
    if [ -d "Phoenix/phoenix-core-lib" ]; then
        cd Phoenix/phoenix-core-lib
        GIT_HOST=$(git remote get-url origin 2>/dev/null | sed -E 's|https?://([^/]+).*|\1|' | sed 's|.*@||')
        cd ../..
    fi
    if [ -n "$GIT_HOST" ]; then
        CREDENTIALS_FILE="$HOME/.git-credentials"
        if [ "$OS" = "Windows_NT" ] || [ -n "$WINDIR" ]; then
            CREDENTIALS_FILE="${USERPROFILE:-$HOME}/.git-credentials"
        fi
        echo "https://oauth2:${GIT_READONLY_TOKEN}@${GIT_HOST}" > "$CREDENTIALS_FILE"
    fi
fi

# Process all Phoenix projects
if [ -d "Phoenix" ]; then
    cd Phoenix
    for repo_dir in */; do
        repo_dir="${repo_dir%/}"
        if [ -d "$repo_dir/.git" ]; then
            echo "Checking out branch $BRANCH in: Phoenix/$repo_dir"
            cd "$repo_dir"
            
            # Stash uncommitted changes
            if [ -n "$(git status --porcelain 2>/dev/null)" ]; then
                git stash push -m "Stashed before checkout - preserving local changes"
                STASHED=true
            else
                STASHED=false
            fi
            
            # Fetch and checkout
            git fetch origin
            
            if git ls-remote --heads origin $BRANCH 2>/dev/null | grep -q $BRANCH; then
                if git show-ref --verify --quiet refs/heads/$BRANCH 2>/dev/null; then
                    git checkout $BRANCH
                else
                    git checkout -b $BRANCH origin/$BRANCH
                fi
            else
                echo "Branch $BRANCH does not exist on remote for $repo_dir"
                [ "$STASHED" = "true" ] && git stash pop 2>/dev/null || true
                cd ..
                continue
            fi
            
            # Unstash if needed
            if [ "$STASHED" = "true" ]; then
                git stash pop 2>/dev/null || true
            fi
            
            cd ..
        fi
    done
    cd ..
fi
```

---

## Error Handling

### Uncommitted Changes Detected
**Strategy:** Automatically stash changes before operations, unstash after successful operations

**Process:**
1. **Automatically stash changes** before operation
2. Proceed with fetch/update/checkout
3. **After successful operation:** Automatically unstash: `git stash pop`
4. If conflicts occur, keep changes stashed and ask user to resolve

### Branch Divergence Detected
**Error:** Local and remote branches have diverged
**Solution:**
1. **Unstash changes before aborting** (if they were stashed)
2. **ABORT update process immediately** for that repository
3. Show divergence details: `git log HEAD...origin/<branch> --oneline`
4. Ask user to choose:
   - **Merge:** `git merge origin/<branch>` (creates merge commit)
   - **Rebase:** `git rebase origin/<branch>` (rewrites history - risky)
   - **Reset:** `git reset --hard origin/<branch>` (discards local changes - very risky)
   - **Abort:** Cancel update
5. Wait for user decision before proceeding

### Merge Conflicts
**Error:** Merge conflicts detected during merge
**Solution:**
1. **Keep changes stashed** (don't unstash yet)
2. Report: "Merge conflicts detected. Changes remain stashed."
3. Show conflict files: `git diff --name-only --diff-filter=U`
4. Ask user to:
   - Resolve conflicts manually
   - After resolution, manually unstash: `git stash pop`
5. Wait for user to resolve conflicts

### Fetch Failure / Authentication Error
**Error:** Failed to fetch from remote or authentication failed
**Solution:**
1. Report error (network/auth issues)
2. **Unstash changes if they were stashed**
3. ABORT process
4. Verify token is set: Check `GIT_READONLY_TOKEN` value (should not be empty)
5. Test token manually: `curl -H "Authorization: Bearer ${GIT_READONLY_TOKEN}" https://git.domain.internal/api/v4/user`
6. Check network connection
7. Verify token has read access to repositories

### Branch Not Found
**Error:** Branch doesn't exist on remote
**Solution:**
1. Report: "Branch <branch> does not exist on remote for <repo>."
2. **Unstash changes if they were stashed**
3. List available branches: `git branch -r`
4. Continue with other repositories
5. Ask user to specify a valid branch name if needed

---

## Important Notes

1. **Automatic Stash/Unstash:** Uncommitted changes are automatically stashed before operations and unstashed after successful operations
2. **All Phoenix Repositories:** All operations are performed on all Git repositories found in `Phoenix/` directory
3. **Supported Branches:** `dev`, `dev2`, `dev-fix`, `test`, `main`, `master` (and any branch that exists on remote)
4. **Safe Operations:** Always fetch before checking branch status
5. **Branch Divergence:** Update will skip repository if branches have diverged - user must choose merge strategy
6. **No Building:** This rule does NOT perform any build steps - it only handles Git operations
7. **Readonly Token:** The token is readonly and cannot modify repositories - safe to include in this file
8. **Standalone:** This rule is completely standalone and does not depend on any other files
9. **Cross-Platform:** Works on Windows (Git Bash/PowerShell), Linux, and macOS
10. **Path Compatibility:** Uses relative paths and automatic workspace detection - no hardcoded absolute paths
11. **Auto-Discovery:** Automatically discovers all Git repositories in `Phoenix/` directory

## ⚠️ COMPATIBILITY WITH SAFETY RULES

**CRITICAL:** This workflow is COMPATIBLE with all safety rules because:

1. **READ-ONLY Operations Only:**
   - `git fetch` - READ-ONLY (downloads from remote, no modifications)
   - `git checkout` - LOCAL operation (switches branches locally)
   - `git merge origin/<branch>` - LOCAL merge only (merges remote changes into local branch)
   - **NO push operations** - Never pushes to remote
   - **NO commit operations** - Never creates commits
   - **NO remote modifications** - Never modifies GitLab repositories

2. **LOCAL Operations Only:**
   - All operations are performed on LOCAL repository copies
   - Merge operations are LOCAL merges that update local working directory
   - No changes are sent to remote GitLab repositories
   - Stash/unstash operations are LOCAL only

3. **Compliance with Safety Rules:**
   - ✅ **Rule 1 (safety_rules.mdc):** No remote modifications - only LOCAL operations
   - ✅ **Rule 14 (safety_rules.mdc):** READ-ONLY mode - fetch and checkout only, no destructive operations
   - ✅ **Rule 100 (autonomous_rules.md):** READ-ONLY operations - no commits, pushes, or remote modifications
   - ✅ **Rule 21 (safety_rules.mdc):** No GitLab modifications - only LOCAL git operations

4. **What This Rule Does NOT Do:**
   - ❌ Does NOT push to GitLab
   - ❌ Does NOT commit changes
   - ❌ Does NOT modify remote repositories
   - ❌ Does NOT create branches on remote
   - ❌ Does NOT delete branches
   - ❌ Does NOT modify GitLab pages or issues (that's IntegrationService's job)

5. **What This Rule DOES:**
   - ✅ Fetches latest changes from GitLab (read-only download)
   - ✅ Updates local branches with remote changes (LOCAL merge)
   - ✅ Switches between branches locally (LOCAL checkout)
   - ✅ Preserves local uncommitted changes (stash/unstash)

**This workflow is a READ-ONLY synchronization tool that keeps local repositories up-to-date with GitLab without modifying remote repositories.**

---

## Testing the Configuration

### Test Token Authentication

```bash
# Set your readonly token
GIT_READONLY_TOKEN="glpat-s3G3rmuJUPbsJBns039NRG86MQp1OjNzCA.01.0y0s67eqg"

# Test token with GitLab API
curl -H "Authorization: Bearer ${GIT_READONLY_TOKEN}" https://git.domain.internal/api/v4/user
```

### Test Git Operations

```bash
# Set token
GIT_READONLY_TOKEN="glpat-s3G3rmuJUPbsJBns039NRG86MQp1OjNzCA.01.0y0s67eqg"

# Configure credential helper
git config --global credential.helper store
GIT_HOST=$(cd Phoenix/phoenix-core-lib && git remote get-url origin | sed -E 's|https?://([^/]+).*|\1|' | sed 's|.*@||')
CREDENTIALS_FILE="$HOME/.git-credentials"
if [ "$OS" = "Windows_NT" ] || [ -n "$WINDIR" ]; then
    CREDENTIALS_FILE="${USERPROFILE:-$HOME}/.git-credentials"
fi
echo "https://oauth2:${GIT_READONLY_TOKEN}@${GIT_HOST}" > "$CREDENTIALS_FILE"

# Test phoenix-core-lib access
cd Phoenix/phoenix-core-lib
git fetch origin --dry-run

# Test phoenix-core access
cd ../phoenix-core
git fetch origin --dry-run
```

### Test Branch Operations

```bash
# Test fetching all projects
!sync

# Test updating a branch
!update dev

# Test checking out a branch
!checkout dev2
```

---

## Troubleshooting

### Token Authentication Failures

**Error:** `fatal: could not read Username for 'https://...': terminal prompts disabled`

**Solution:**
1. Verify token is set: `echo $GIT_READONLY_TOKEN` (should not be empty)
2. Configure credential helper: `git config --global credential.helper store`
3. Add token to credentials: 
   ```bash
   GIT_HOST=$(cd Phoenix/phoenix-core-lib && git remote get-url origin | sed -E 's|https?://([^/]+).*|\1|' | sed 's|.*@||')
   CREDENTIALS_FILE="$HOME/.git-credentials"
   if [ "$OS" = "Windows_NT" ] || [ -n "$WINDIR" ]; then
       CREDENTIALS_FILE="${USERPROFILE:-$HOME}/.git-credentials"
   fi
   echo "https://oauth2:${GIT_READONLY_TOKEN}@${GIT_HOST}" > "$CREDENTIALS_FILE"
   ```
4. Test token: `curl -H "Authorization: Bearer ${GIT_READONLY_TOKEN}" https://git.domain.internal/api/v4/user`

**Error:** `401 Unauthorized` or `403 Forbidden`

**Solution:**
1. Verify token has read permissions
2. Check token hasn't expired
3. Verify token has access to all repositories
4. Regenerate token if needed

### Git Fetch Failures

**Error:** `Permission denied (publickey)`

**Solution:**
- This error occurs with SSH authentication
- Switch to HTTPS and use the readonly token instead
- Update remote URL: `git remote set-url origin https://git.domain.internal/phoenix/repo.git`

### Branch Not Found

**Error:** `fatal: couldn't find remote ref <branch>`

**Solution:**
- Verify branch name is correct (dev, dev2, dev-fix, test, main, master)
- List available branches: `git branch -r`
- Check if branch exists on remote: `git ls-remote --heads origin`
- Some repositories may not have all branches - this is normal

### Workspace Detection Issues

**Error:** Cannot find Phoenix directory

**Solution:**
1. Set `WORKSPACE_ROOT` environment variable: `export WORKSPACE_ROOT=/path/to/workspace`
2. Or run the command from the workspace root directory
3. Verify `Phoenix/` directory exists and contains Git repositories

---

## Summary

This standalone rule provides:
- ✅ Initial fetch of all Phoenix projects (`!sync`) using readonly token
- ✅ Update specified branches (`!update <branch>`) using readonly token
- ✅ Checkout specified branches (`!checkout <branch>`) using readonly token
- ✅ Readonly Personal Access Token configuration
- ✅ Automatic stash/unstash of local changes
- ✅ Support for branches: dev, dev2, dev-fix, test, main, master
- ✅ Auto-discovery of all Git repositories in `Phoenix/` directory
- ✅ Completely standalone - no dependencies on other files
- ✅ Cross-platform compatible - works on Windows, Linux, macOS
- ✅ Path compatible - uses relative paths and automatic detection
- ✅ Windows PowerShell and Git Bash support

**✅ Token is configured and ready to use!**

**Usage:**
- Type `!sync` to fetch all Phoenix projects
- Type `!update dev` to update dev branch in all projects
- Type `!checkout dev2` to checkout dev2 branch in all projects
- Always use this workflow for downloading or updating projects from GitLab
