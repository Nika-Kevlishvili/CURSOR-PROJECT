---
alwaysApply: true
---

# DATABASE WORKFLOW RULES [CRITICAL - MANDATORY]

## Rule DB.0: MANDATORY Database Selection and MCP Configuration Check [CRITICAL - ABSOLUTE PRIORITY]

**CRITICAL RULE - MUST BE FOLLOWED BEFORE ANY DATABASE OPERATION:**

### Before ANY Database Query:
1. **NEVER assume default database connection**
2. **ALWAYS check MCP configuration** (`mcp.json` or MCP server settings) to see current connection parameters
3. **ALWAYS verify database name and environment** (Test, Dev, Dev2, PreProd, Prod) from MCP configuration
4. **ALWAYS ask user which database/environment to use** if not explicitly specified in the conversation
5. **ALWAYS use the environment specified at the beginning of the conversation** for that entire chat session

### Workflow:
1. **Check MCP Configuration First:**
   - Review MCP server configuration to see available databases
   - Identify which environment each database belongs to (Test, Dev, Dev2, PreProd, Prod)
   - Note the exact connection parameters (host, port, database name, user, password)

2. **Verify User Intent:**
   - If user mentions environment at conversation start (e.g., "dev გარემოზე", "Test environment"), use that environment for entire session
   - If no environment specified, **MUST ASK**: "Which database/environment should I use? (Test, Dev, Dev2, PreProd, Prod)"
   - **NEVER assume or use default connection**

3. **Connection Process:**
   - Use the correct MCP server based on environment:
     - PostgreSQLTest for Test
     - PostgreSQLDev for Dev
     - PostgreSQLDev2 for Dev2
     - PostgreSQLPreProd for PreProd
     - PostgreSQLProd for Prod
   - Use connection details from MCP configuration, NOT from rules (rules may be outdated)
   - Always connect explicitly before queries

4. **Session Consistency:**
   - Once environment is determined at conversation start, use it consistently throughout the session
   - If user changes environment mid-conversation, acknowledge and switch

### Example:
```
User: "dev გარემოზე მაქვს პრობლემა..."
AI: [Checks MCP config for Dev environment connection details]
    [Uses PostgreSQLDev MCP server with correct parameters]
    [Uses Dev environment for entire session]
```

### Violation Consequences:
- Using wrong database/environment is a **CRITICAL SYSTEM ERROR**
- Never assume default connection
- Always verify from MCP configuration
- Always ask if uncertain

**This rule takes ABSOLUTE PRIORITY over all other database rules.**

**ALWAYS use the EXACT environment that the user requests. NEVER switch to a different environment.**

- If user says "Dev" → Use PostgreSQLDev (10.236.20.21)
- If user says "Dev2" → Use PostgreSQLDev2 (10.236.20.22)
- If user says "Test" → Use PostgreSQLTest (10.236.20.24)
- If user says "PreProd" → Use PostgreSQLPreProd (10.236.20.76)
- If user says "Prod" → Use PostgreSQLProd (10.236.20.78:5000, readonly_user)

## Rule DB.1: PostgreSQL MCP Connection Details [CRITICAL]

### PostgreSQLDev - Dev Environment
- **Host:** `10.236.20.21`
- **Port:** `5432`
- **Database:** `phoenix`
- **User:** `postgres`
- **Password:** `rakX5thB2qO3`

### PostgreSQLDev2 - Dev2 Environment
- **Host:** `10.236.20.22`
- **Port:** `5432`
- **Database:** `phoenix`
- **User:** `postgres`
- **Password:** `uj6MfFgUkV1R`

### PostgreSQLTest - Test Environment
- **Host:** `10.236.20.24`
- **Port:** `5432`
- **Database:** `phoenix`
- **User:** `postgres`
- **Password:** `U&Vd2Ge@nyM1`

### PostgreSQLPreProd - PreProd Environment
- **Host:** `10.236.20.76`
- **Port:** `5432`
- **Database:** `phoenix`
- **User:** `postgres`
- **Password:** `U&Vd2Ge@nyM1`

### PostgreSQLProd - Production Environment (READ-ONLY)
- **Host:** `10.236.20.78`
- **Port:** `5000`
- **Database:** `phoenix`
- **User:** `readonly_user`
- **Password:** `U$CM)*qr&Zb4JfU@`

### Connection Steps:
```python
# Example for Dev environment
mcp_PostgreSQLDev_connect_db(
    host="10.236.20.21",
    port=5432,
    user="postgres",
    password="rakX5thB2qO3",
    database="phoenix"
)

# Then execute queries
mcp_PostgreSQLDev_query(sql="SELECT ...")
```

### Query Execution:
- **ALWAYS connect first** using the appropriate `mcp_PostgreSQL{Env}_connect_db()` before executing queries
- Use `mcp_PostgreSQL{Env}_query()` for SELECT queries
- Use `mcp_PostgreSQL{Env}_execute()` for INSERT/UPDATE/DELETE operations (if needed)
- Connection persists for the session, but reconnect if connection errors occur

### Available MCP Servers:
- **PostgreSQLDev** - Dev environment (10.236.20.21:5432/phoenix)
- **PostgreSQLDev2** - Dev2 environment (10.236.20.22:5432/phoenix)
- **PostgreSQLTest** - Test environment (10.236.20.24:5432/phoenix)
- **PostgreSQLPreProd** - PreProd environment (10.236.20.76:5432/phoenix)
- **PostgreSQLProd** - Production environment (10.236.20.78:5000/phoenix, READ-ONLY)

## Rule DB.2: Standard Query Patterns [IMPORTANT]

### Finding Contracts by POD Identifier:

**Product Contracts:**
```sql
SELECT DISTINCT
    'PRODUCT_CONTRACT' as contract_type,
    c.id as contract_id,
    c.contract_number,
    c.status,
    c.contract_status,
    c.create_date,
    c.entry_into_force_date,
    c.termination_date,
    p.identifier as pod_identifier,
    cp.id as contract_pod_id,
    cp.activation_date,
    cp.deactivation_date,
    cp.status as contract_pod_status
FROM product_contract.contracts c
JOIN product_contract.contract_details cd ON cd.contract_id = c.id
JOIN product_contract.contract_pods cp ON cp.contract_detail_id = cd.id
JOIN pod.pod_details pd ON cp.pod_detail_id = pd.id
JOIN pod.pod p ON pd.pod_id = p.id
WHERE p.identifier = 'POD_IDENTIFIER_HERE'
ORDER BY c.contract_number, c.id
```

**Service Contracts:**
```sql
SELECT DISTINCT
    'SERVICE_CONTRACT' as contract_type,
    c.id as contract_id,
    c.contract_number,
    c.status,
    c.contract_status,
    c.create_date,
    c.entry_into_force_date,
    c.termination_date,
    p.identifier as pod_identifier,
    cp.id as contract_pod_id,
    cp.status as contract_pod_status
FROM service_contract.contracts c
JOIN service_contract.contract_details cd ON cd.contract_id = c.id
JOIN service_contract.contract_pods cp ON cp.contract_detail_id = cd.id
JOIN pod.pod p ON cp.pod_id = p.id
WHERE p.identifier = 'POD_IDENTIFIER_HERE'
ORDER BY c.contract_number, c.id
```

### Key Schema Relationships:
- **Product Contracts:** `contracts` → `contract_details` → `contract_pods` → `pod_details` → `pod`
- **Service Contracts:** `contracts` → `contract_details` → `contract_pods` → `pod` (direct pod_id)
- **POD Identifier:** Stored in `pod.pod.identifier` (varchar(33))

## Rule DB.3: Query Best Practices [IMPORTANT]

1. **Always use DISTINCT** when joining multiple tables to avoid duplicate rows
2. **Include contract_type** in results to distinguish Product vs Service contracts
3. **Order results** by contract_number and contract_id for consistency
4. **Include relevant dates** (create_date, entry_into_force_date, termination_date, activation_date, deactivation_date)
5. **Include status fields** (contract status, contract_pod status) for context

## Rule DB.4: Error Handling [IMPORTANT]

- If connection fails, verify credentials and network access
- If query fails, check SQL syntax and table/schema names
- Always handle empty result sets gracefully
- Log errors with full context for debugging

## Rule DB.5: Security [CRITICAL]

- **NEVER commit database credentials** to version control
- **NEVER log passwords** in responses or reports
- Use MCP environment variables for credentials when possible
- Credentials are stored in MCP configuration, not in code

## Rule DB.6: Workflow Integration [IMPORTANT]

When database queries are needed:
1. Connect using PostgreSQLTest MCP (Rule DB.1)
2. Execute queries using standard patterns (Rule DB.2)
3. Format results clearly for user
4. Include all relevant contract and POD information
5. Follow reporting rules (Rule 0.6) if task involves database queries

**Violation of database workflow rules is a CRITICAL SYSTEM ERROR.**
